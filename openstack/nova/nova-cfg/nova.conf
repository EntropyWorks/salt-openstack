{{pillar['headers']['salt']['file']}}
[DEFAULT]
# Show more verbose log output (sets INFO log level output)
{%- if salt['pillar.get']('nova:verbose', False ) %}
verbose = {{ salt['pillar.get']('nova:verbose') }}
{% endif %}

# Show debugging output in logs (sets DEBUG log level output)
{%- if salt['pillar.get']('nova:debug', False ) %}
debug = {{ salt['pillar.get']('nova:debug') }}
{% endif %}

node_availability_zone = {{ salt['pillar.get']('endpoints:nova:availability_zone', 'RegionOne') }}
default_availability_zone = {{ salt['pillar.get']('endpoints:nova:availability_zone', 'RegionOne') }}

cpu_allocation_ratio = {{ salt['pillar.get']('nova:cpu_allocation_ratio', '16.0') }}
max_cores = {{ salt['pillar.get']('nova:max_cores', '25') }}

# (BoolOpt) If true, allow overcommitting of vcpus on
skip_isolated_core_check = {{ salt['pillar.get']('nova:skip_isolated_core_check', 'False') }}

allow_resize_to_same_host = {{ salt['pillar.get']('nova:allow_resize_to_same_host','True') }}

{% if grains.get('network_topic', False) -%}
# This must be a grain that is set.
# The topic network nodes listen on (string value) for
# the custom plugin HP is using.
{%- set network_topic = grains['network_topic'] %}
network_topic={{ network_topic }}
{% else -%}
network_topic=Net_Topic_XXX
{% endif -%}

# Default value for multi_host in networks. Also, if set, some
# rpc network calls will be sent directly to host. (boolean
# value)
multi_host = {{ salt['pillar.get']('nova:multi_host', 'False') }}

send_arp_for_ha = {{ salt['pillar.get']('nova:send_arp_for_ha', 'False') }}

enabled_apis = {{ salt['pillar.get']('nova:enabled_apis', 'ec2,osapi_compute,metadata') }}
enabled_ssl_apis = {{ salt['pillar.get']('nova:enabled_ssl_apis', 'ec2,osapi_compute,metadata') }}
scheduler_available_filters = {{ salt['pillar.get']('nova:scheduler_all_filter_classes', 'nova.scheduler.filters.all_filters')  }}

{%- if pillar['nova']['scheduler_custom_az_filter_class'] %}
scheduler_available_filters = {{ pillar['nova']['scheduler_custom_az_filter_class'] }}
{% endif -%}

scheduler_default_filters = {{ salt['pillar.get']('nova:scheduler_default_filters', 'AggregateInstanceExtraSpecsFilter,HostAvailabilityZoneFilter,AvailabilityZoneFilter,RamFilter,CoreFilter,DifferentHostFilter,DiskFilter,GroupAntiAffinityFilter,RetryFilter,SameHostFilter,SimpleCIDRAffinityFilter,ComputeFilter') }}
scheduler_host_subset_size = {{ salt['pillar.get']('nova:scheduler_host_subset_size', '5') }}


# Config for a Nova Controller Node
# MySQL Connection #
sql_connection = mysql://nova:{{ salt['pillar.get']('secrets:nova:db_password', 'password') }}@{{ salt['pillar.get']('endpoints:hosts:database', '127.0.0.1') }}/nova?charset=utf8
sql_idle_timeout = {{ salt['pillar.get']('nova:sql_idle_timeout', '360') }}
#  IP address for OpenStack API to listen
osapi_volume_listen = {{ salt['pillar.get']('endpoints:nova:osapi_volume_listen', '0.0.0.0') }}

{% if pillar['nova']['use_s3'] %}
# s3 Services offered #
s3_host = {{ salt['pillar.get']('nova:s3_host') }}
cc_host = {{ salt['pillar.get']('nova:cc_host') }}

# IP address for EC2 API to listen
ec2_listen = {{ salt['pillar.get']('nova:ec2_listen') }}
ec2_host = {{ salt['pillar.get']('nova:ec2_host') }}
ec2_dmz_host = {{ salt['pillar.get']('nova:ec2_dmz_host') }}
ec2_url = {{ salt['pillar.get']('nova:ec2_url') }}
{% endif %}

osapi_compute_listen = {{ salt['pillar.get']('endpoints:nova:osapi_compute_listen', '0.0.0.0') }}
# Number of workers to start for nova-api
osapi_compute_workers = {{ salt['pillar.get']('nova:osapi_compute_workers', '10') }}
# IP address for metadata api to listen
metadata_listen = {{ salt['pillar.get']('endpoints.nova.metadata_listen', '0.0.0.0') }}
# (IntOpt) Number of workers for metadata API
metadata_workers = {{ salt['pillar.get']('nova:metadata_workers', '10' )}}

# Logging #
use_syslog = {{ salt['pillar.get']('nova.use_syslog', 'False') }}
syslog_log_facility = {{ salt['pillar.get']('nova:syslog_log_facility', 'LOG_LOCAL0') }}
logdir = {{ salt['pillar.get']('nova:logdir', '/var/log/nova') }}
state_path = {{ salt['pillar.get']('nova:state_path', '/var/lib/nova') }}
lock_path = {{ salt['pillar.get']('nova:lock_path', '/var/lock/nova') }}

# Paths to important items #
rootwrap_config = {{ salt['pillar.get']('nova:rootwrap_config', '/etc/nova/rootwrap.conf') }}
api_paste_config = {{ salt['pillar.get']('nova:api_paste_config', '/etc/nova/api-paste.ini') }}
keys_path = {{ salt['pillar.get']('nova:keys_path', '/var/lib/nova/keys') }}

# Auth
use_deprecated_auth = {{ salt['pillar.get']('nova:use_deprecated_auth', 'false') }}
auth_strategy = {{ salt['pillar.get']('nova:auth_strategy', 'keystone') }}
keystone_ec2_url = {{ salt['pillar.get']('keystone:service_protocol', 'http') }}://{{ salt['pillar.get']('keystone:service_host', '127.0.0.1') }}:{{ salt['pillar.get']('keystone:service_port', '5000') }}/v2.0/ec2tokens

# Imaging service
image_service = {{ salt['pillar.get']('nova:image_service','nova.image.glance.GlanceImageService') }}
glance_api_servers = {{ salt['pillar.get']('glance:protocol', 'http') }}://{{ salt['pillar.get']('glance:host', '127.0.0.1') }}:{{ salt['pillar.get']('glance:port', '9292') }}
glance_api_insecure = {{ salt['pillar.get']('nova:glance_api_insecure','True') }}

novnc_enabled = {{ salt['pillar.get']('nova:novnc_enabled','True') }}
novncproxy_base_url = http://{{ salt['network.interfaces']()['bond0']['inet'][0]['address'] }}:{{ salt['pillar.get']('nova:novncproxy_port','6080') }}/vnc_auto.html
novncproxy_port = {{ salt['pillar.get']('nova:novncproxy_port','6080') }}
vncserver_proxyclient_address = {{ salt['network.interfaces']()['bond0']['inet'][0]['address'] }}
vncserver_listen = {{ salt['network.interfaces']()['bond0']['inet'][0]['address'] }}

firewall_driver = {{ salt['pillar.get']('nova:firewall_driver', 'nova.virt.libvirt.firewall.IptablesFirewallDriver') }}
dhcpbridge_flagfile = {{ salt['pillar.get']('nova:dhcpbridge_flagfile', '/etc/nova/nova.conf') }}

# Not sure about this right now..
dhcpbridge = {{ salt['pillar.get']('nova:dhcpbridge','/usr/local/bin/dbaas-nova-dhcpbridge') }}

network_manager = {{ salt['pillar.get']('nova:network_manager', 'nova.network.manager.FlatDHCPManager') }}
public_interface = {{ salt['pillar.get']('endpoints:nova:network:public_interface', 'eth0') }}
my_ip = {{ salt['network.interfaces']()['bond0']['inet'][0]['address'] }}

flat_interface = {{ salt['pillar.get']('endpoints:nova:network:flat_interface', 'eth0') }}
flat_network_bridge = {{ salt['pillar.get']('nova:flat_network_bridge', 'br100') }}
default_floating_pool = {{ salt['pillar.get']('endpoints:nova:default_floating_pool', 'public') }}
auto_assign_floating_ip = {{ salt['pillar.get']('nova:auto_assign_floating_ip', 'True') }}
force_dhcp_release = {{ salt['pillar.get']('nova:force_dhcp_release', 'true') }}
update_dns_entries = {{ salt['pillar.get']('nova:update_dns_entries', 'true') }}

{% if pillar['nova']['use_lvm'] %}
# LVM
libvirt_images_type = {{ salt['pillar.get']('nova:libvirt_images_type','lvm') }}
libvirt_images_volume_group = {{ salt['pillar.get']('nova:libvirt_images_volume_group', 'customer') }}
{% endif -%}


# Rabbit #
{% if pillar['endpoints']['hosts']['rabbit_cluster'] -%}
# Rabbit Cluster Setup #
rabbit_hosts = "{{ pillar['endpoints']['hosts']['rabbit_cluster'] }}"
{% else -%}
# Rabbit Setup #
rabbit_host = {{ pillar['endpoints']['hosts']['rabbit'] }}
rabbit_port = {{ salt['pillar.get']('rabbit:rabbit_port','5672') }}
{% endif -%}
{% if pillar['rabbit']['use_ssl'] -%}
rabbit_use_ssl: true
{% endif -%}
{% if pillar['rabbit']['ha_queues'] -%}
rabbit_ha_queues: true
{% endif -%}
rabbit_userid = guest
rabbit_password = {{ salt['pillar.get']('secrets:rabbit:password', 'guest') }}
rabbit_virtual_host = /

# Virt driver
# The Ubuntu packages place this in /etc/nova/nova-compute.conf
#
libvirt_use_virtio_for_bridges = {{ salt['pillar.get']('nova:libvirt_use_virtio_for_bridges','true') }}
resume_guests_state_on_host_boot = {{ salt['pillar.get']('nova:resume_guests_state_on_host_boot','true') }}
libvirt_sparse_logical_volumes = {{ salt['pillar.get']('nova:libvirt_sparse_logical_volumes','false') }}
libvirt_snapshot_compression = {{ salt['pillar.get']('nova:libvirt_snapshot_compression','true' ) }}

# Resize Options
# Clean up deleted instances
resize_confirm_window = {{ salt['pillar.get']('nova:resize_confirm_window','43200') }}

# Clean up deleted instances
# Action to take if a running deleted instance is
# detected.Valid options are 'noop', 'log' and 'reap'. Set to
# 'noop' to disable. (string value)
running_deleted_instance_action = {{ salt['pillar.get']('nova:running_deleted_instance_action','reap') }}

# Number of seconds to wait between runs of the cleanup task.
# (integer value)
running_deleted_instance_poll_interval = {{ salt['pillar.get']('nova:running_deleted_instance_poll_interval','1800') }}

# Number of seconds after being deleted when a running
# instance should be considered eligible for cleanup. (integer
# value)
running_deleted_instance_timeout = {{ salt['pillar.get']('nova:running_deleted_instance_timeout','43200') }}

# Quotas
quota_cores = {{ salt['pillar.get']('nova:quota_cores','40') }}
quota_ram = {{ salt['pillar.get']('nova:quota_ram','327680') }}
quota_security_groups = {{ salt['pillar.get']('nova:quota_security_groups','11') }}

# ================= SSL Options ===============================
# Certificate file to use when starting API server securely
ssl_cert_file = {{ salt['pillar.get']('nova:ssl_cert_file','/etc/nova/ssl/hpcs_cert.pem') }}
# Private key file to use when starting API server securely
ssl_key_file = {{ salt['pillar.get']('nova:ssl_key_file','/etc/nova/ssl/hpcs_key.pem') }}

remove_unused_base_images = {{ salt['pillar.get']('nova:remove_unused_base_images','True') }}
image_cache_manager_interval = {{ salt['pillar.get']('nova:image_cache_manager_interval','60') }}
remove_unused_original_minimum_age_seconds = {{ salt['pillar.get']('nova:remove_unused_original_minimum_age_seconds','0') }}
remove_unused_resized_minimum_age_seconds = {{ salt['pillar.get']('nova:remove_unused_resized_minimum_age_seconds','3600') }}


[conductor]
#
# Options defined in nova.conductor.api
#
# Perform nova-conductor operations locally (boolean value)
use_local = {{ salt['pillar.get']('nova:use_local','true') }}
